# 생성자 함수, 재귀 함수

## 재귀함수
> 재귀 함수는 함수의 내용에서 다시 함수 이름으로 함수의 내용 안에서 실행되는 것이 반복되는 방식/
> for문으로 반복문으로 구현 가능한 로직들은 재귀함수로 대부분 작성이 가능하다.
> 재귀 함수를 사용하는 이유는 반복하는 내용의 기능을 여러개로 나눠서 직관적으로 관리할때
> 사용하는 프로그래밍 패턴중의 하나.

 1 + 2 / 3 * 4 + 5

 > 재귀를 작성할때 더이상 나눠줘야 할 필요가 없을때가 종료시점.
 > 문제를 나눠서 기능을 작성하는 경우 패턴을 찾아서 활용 해야한다.

 ## 사용 예)

 ## 반복문을 사용해서 만든 로직

 ```js
 // 1 ~ 100 더한 수
 let result = 0

 for(let i = 1; i <= 100; i++) {
    result += i;
 }
 // 100 까지 더한 수
 
 // 연산식을 사용한 예
 let n = 100;
 console.log((n / 2) * (n + 1));
 // 알고리즘 풀면서 외우는 것
 // 1 ~ 100까지 더한 수

 // 재귀 함수를 사용한 예
 function sum(n, result) {
    if(n === 101) {
        console.log(result);
        return n;
    }
    sum(n + 1, result + n);
 }

 sum(1,0)

 function sum2(n, result) {
    if(n === 101) {
        return result;
    }
    return sum(n + 1, result + n);
 }

 console.log(sum2(1,0));
 ```

> 재귀함수는 잘쓰지 못하면 그냥 반복문으로 돌리는 것보다 못하다 최적화가 안좋다.

## 재귀 함수의 목적
> 장점으로 반복문을 많이 사용하는 경우보다 코드의 간결성과 직관성이 증가한다.
> 하지만 단점으로 스택에 함수의 실행이 많이 쌓여서 메모리의 공간이 많이 차지된다. 속도 성능 저하.


## 피보나치 수열
> 피보나치 수열은 토기가 처음에 한쌍이 있고
> 한달이 지나면 한쌍의 토끼가 성장
> 그 이후 한달이 지나면 성장한 토끼가 새끼토끼를 한쌍을 낳는다
> 그 이후 한달이 지나면 성장한 토끼는 또 새끼 한쌍을 낳고 이전 달의 새끼 토끼 한쌍은 성장한다.
> 이런식으로 계속 증가하는 수열
> 규칙 토끼는수명이 무한 죽지않는

```js
function fibo(n) {
    if(n === 1 || n === 2) return 1; // 한쌍의 토끼
    return fibo(n - 1) + fibo(n - 2); // 토끼가 성장하고 한쌍의 새끼 토끼를 낳는 값을 구하기 위해서.
}
```

> 수학 공식을 공부할건 아니니까 프로그래머스 백준 등을 풀면서

### 자바스크립트의 실행 시간 복잡도를 한번 확인 해보자.
> 코드의 실행이 얼마나 걸렸는지 


// 계산기 구현할때 => 사칙연산 처리할때


## 생성자 함수
> 객체를 생성 하기위한 함수
> 객체를 생성의 목표를 가지고 있다.
> function 키워드를 사용해서 생성자 함수를 만드는데 이후에 class
> ES5까지는 function 키워드로 객체의 생성자 함수를 만들었다.
> 만능 function 기능의 작성과 객체의 생성과 여러가지로 사용을 하는 느낌
> ES6 부터 이러한 부분들이 바뀌는 키워드가 많이 추가 되었다.


> ES6
> 화살표 함수 (this 개념), class (객체 생성을 위해서만 만들어진 예약어) , 메서드 축약형  
```js
// 생성자 함수
// 하나의 인스턴스
// 공장에서 상품을 만드는 기계같은 느낌
// 자동차 객체 하나 생성

// function 안의 this는 바인딩 한다는 의미는 바로 위의 객체를 참조한다.
// function에서 this의 키워드는 동적으로 변한다.
// 함수를 호출한 위치에서 this를 바인딩 한다.
// 코드상의 this를 작성한 영역에서 객체를 참조하는게 화살표 함수
function myCar() {
    this.color = color;
    this.name = name;
}

myCar("red", "GV60"); // this 바인딩이 일어나서 
// this가 바인딩 되는 객체는 전역에 코드를 작성했고
// 브라우저 환경에서 실행되는데 전역객체인 window객체에 키와 값으로 할당된다.

// 이미 만들어진 상품 2개만 들고있는 것
// 동적으로 생성할수 없지
const obj = {
    color : "red",
    name : "GV60"
}

const obj2 = {
    color : "black",
    name : "SUV"
}

// 생성자 함수 사용
// new 예약어 (동적할당) 메모리에 새로운 객체를 만들어서 할당한다.
// [new 예약어] [생성자 함수 실행]
const obj3 = new myCar("red", "GV70");

// return을 생성한 객체의 주소를 반환한다.

```

> 하고싶은 사람 8명
> 함수를 사용해서 계산기를 구현 해주세요
> 값을 입력을 받고 다음 연산자를 입력 받고 두번째 값을 입력 받아서 출력 하는 것

> 함수로
> 돈을 입력하면 잔돈 계산기 100원 짜리로는 몇개 1000원 짜리로는 몇개 10000원 짜리는 몇개 

> 페어 코딩 하는 방법
> 코드를 치는 사람은 반박하면 안돼 처음에 설계 정도는 주석으로 같이 정리하고
> 말하는 사람은 코드 치면 안된다.
> 한번 구현 끝나면 다음으로 바꿔서 
